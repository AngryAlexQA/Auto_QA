# Домашнее задание №12 - `Александра Бужор`

## 1. Тест для модальных окон

```python
# demoqa_home/tests/tests_hw/test_check_modal.py
import pytest
import requests
from pages.modal_dialogs_page import ModalDialogsPage


class TestModalDialogs:
    """Тесты для модальных окон."""
    
    def is_page_available(self, url):
        """Проверяет доступность страницы."""
        try:
            response = requests.get(url, timeout=10)
            return response.status_code == 200
        except requests.RequestException:
            return False
    
    @pytest.mark.skipif(not self.is_page_available("https://demoqa.com/modal-dialogs"), 
                       reason="Страница недоступна")
    def test_modal_dialogs_functionality(self, driver):
        """
        Тест функциональности модальных окон.
        
        Steps:
        a. страница https://demoqa.com/modal-dialogs
           i. на странице присутствуют 2 кнопки "Small modal" и "Large modal"
           ii. при клике на каждую открывается модальное окно
           iii. у каждого окна есть кнопка "close" по клику окно закрывается
        """
        modal_page = ModalDialogsPage(driver)
        modal_page.visit()
        
        # i. Проверяем наличие кнопок
        assert modal_page.is_small_modal_button_visible() == True, "Кнопка Small modal не найдена"
        assert modal_page.is_large_modal_button_visible() == True, "Кнопка Large modal не найдена"
        
        # ii. Тестируем Small modal
        modal_page.click_small_modal_button()
        assert modal_page.is_small_modal_visible() == True, "Small modal не открылся"
        
        # iii. Закрываем Small modal
        modal_page.close_small_modal()
        assert modal_page.is_small_modal_visible() == False, "Small modal не закрылся"
        
        # ii. Тестируем Large modal
        modal_page.click_large_modal_button()
        assert modal_page.is_large_modal_visible() == True, "Large modal не открылся"
        
        # iii. Закрываем Large modal
        modal_page.close_large_modal()
        assert modal_page.is_large_modal_visible() == False, "Large modal не закрылся"
```

## 2. Обновляем ModalDialogsPage

```python
# demoqa_home/pages/modal_dialogs.py (дополняем)
class ModalDialogsPage(BasePage):
    # ... существующий код ...
    
    # Добавляем локаторы для модальных окон
    small_modal_button = "#showSmallModal"
    large_modal_button = "#showLargeModal"
    small_modal = ".modal-sm"
    large_modal = ".modal-lg"
    close_small_modal_button = "#closeSmallModal"
    close_large_modal_button = "#closeLargeModal"
    
    def is_small_modal_button_visible(self):
        """Проверяет видимость кнопки Small modal."""
        return self.is_element_visible(self.small_modal_button)
    
    def is_large_modal_button_visible(self):
        """Проверяет видимость кнопки Large modal."""
        return self.is_element_visible(self.large_modal_button)
    
    def click_small_modal_button(self):
        """Клик по кнопке Small modal."""
        self.find_element(self.small_modal_button).click()
    
    def click_large_modal_button(self):
        """Клик по кнопке Large modal."""
        self.find_element(self.large_modal_button).click()
    
    def is_small_modal_visible(self):
        """Проверяет видимость Small modal."""
        return self.is_element_visible(self.small_modal)
    
    def is_large_modal_visible(self):
        """Проверяет видимость Large modal."""
        return self.is_element_visible(self.large_modal)
    
    def close_small_modal(self):
        """Закрывает Small modal."""
        self.find_element(self.close_small_modal_button).click()
    
    def close_large_modal(self):
        """Закрывает Large modal."""
        self.find_element(self.close_large_modal_button).click()
```

## 3. Тест для алертов

```python
# demoqa_home/tests/tests_hw/test_check_alert.py
import pytest
import time
from selenium.webdriver.common.alert import Alert
from pages.alerts_page import AlertsPage


class TestAlerts:
    """Тесты для алертов."""
    
    def test_timer_alert(self, driver):
        """
        Тест таймерного алерта.
        
        Steps:
        a. Страница https://demoqa.com/alerts
           i. на странице присутствует кнопка "#timerAlertButton"
           ii. через 5 сек после клика на кнопку всплывает алерт
        """
        alerts_page = AlertsPage(driver)
        alerts_page.visit()
        
        # i. Проверяем наличие кнопки
        assert alerts_page.is_timer_alert_button_visible() == True, "Кнопка timerAlertButton не найдена"
        
        # ii. Кликаем на кнопку и ждем алерт
        alerts_page.click_timer_alert_button()
        
        # Ждем появления алерта
        time.sleep(6)  # Ждем 5 секунд + запас
        
        # Переключаемся на алерт
        alert = Alert(driver)
        assert alert.text is not None, "Алерт не появился"
        
        # Закрываем алерт
        alert.accept()
```

## 4. Page Object для алертов

```python
# demoqa_home/pages/alerts_page.py
from pages.base_page import BasePage


class AlertsPage(BasePage):
    """Класс для работы со страницей Alerts."""
    
    def __init__(self, driver):
        super().__init__(driver)
        self.url = "https://demoqa.com/alerts"
        
        # Локаторы элементов
        self.timer_alert_button = "#timerAlertButton"
    
    def visit(self):
        """Переход на страницу Alerts."""
        self.driver.get(self.url)
    
    def is_timer_alert_button_visible(self):
        """Проверяет видимость кнопки timer alert."""
        return self.is_element_visible(self.timer_alert_button)
    
    def click_timer_alert_button(self):
        """Клик по кнопке timer alert."""
        self.find_element(self.timer_alert_button).click()
```

## 5. Тест для сортировки таблицы

```python
# demoqa_home/tests/tests_hw/test_sort.py
import pytest
from pages.webtables_page import WebTablesPage


class TestWebTablesSorting:
    """Тесты сортировки Web Tables."""
    
    def test_table_sorting(self, driver):
        """
        Тест сортировки таблицы.
        
        Steps:
        a. Страница https://demoqa.com/webtables
        b. при клике на каждый заголовок столбца страницы, происходит сортировка таблицы по этому столбцу
        """
        web_tables_page = WebTablesPage(driver)
        web_tables_page.visit()
        
        # Локаторы заголовков столбцов
        column_headers = [
            "#app > div > div > div.row > div.col-12.mt-4.col-md-6 > div.web-tables-wrapper > div.ReactTable.-striped.-highlight > div.rt-table > div.rt-thead.-header > div > div:nth-child(1)",
            "#app > div > div > div.row > div.col-12.mt-4.col-md-6 > div.web-tables-wrapper > div.ReactTable.-striped.-highlight > div.rt-table > div.rt-thead.-header > div > div:nth-child(2)",
            "#app > div > div > div.row > div.col-12.mt-4.col-md-6 > div.web-tables-wrapper > div.ReactTable.-striped.-highlight > div.rt-table > div.rt-thead.-header > div > div:nth-child(3)",
            "#app > div > div > div.row > div.col-12.mt-4.col-md-6 > div.web-tables-wrapper > div.ReactTable.-striped.-highlight > div.rt-table > div.rt-thead.-header > div > div:nth-child(4)",
            "#app > div > div > div.row > div.col-12.mt-4.col-md-6 > div.web-tables-wrapper > div.ReactTable.-striped.-highlight > div.rt-table > div.rt-thead.-header > div > div:nth-child(5)",
            "#app > div > div > div.row > div.col-12.mt-4.col-md-6 > div.web-tables-wrapper > div.ReactTable.-striped.-highlight > div.rt-table > div.rt-thead.-header > div > div:nth-child(6)"
        ]
        
        for i, header_locator in enumerate(column_headers):
            # Кликаем на заголовок
            header = web_tables_page.find_element(header_locator)
            header.click()
            
            # Проверяем, что добавился класс сортировки
            class_attribute = header.get_attribute("class")
            assert "sortable" in class_attribute or "rt-th" in class_attribute, \
                f"Заголовок {i+1} не имеет классов сортировки"
            
            # Можно добавить более сложную проверку фактической сортировки данных
            # но по заданию достаточно проверки класса
```

## 6. Тест для новых вкладок

```python
# demoqa_home/tests/tests_hw/test_window_tab.py
import pytest
from selenium.webdriver.common.by import By
from pages.links_page import LinksPage


class TestLinks:
    """Тесты для ссылок и новых вкладок."""
    
    def test_home_link_new_tab(self, driver):
        """
        Тест ссылки Home.
        
        Steps:
        a. Страница https://demoqa.com/links
        b. На странице имеется ссылка "Home"
        c. текст ссылки == "Home"
        d. href ссылки == "https://demoqa.com"
        e. При клике на ссылку открывается новая вкладка
        """
        links_page = LinksPage(driver)
        links_page.visit()
        
        # b. Проверяем наличие ссылки
        assert links_page.is_home_link_visible() == True, "Ссылка Home не найдена"
        
        # c. Проверяем текст ссылки
        link_text = links_page.get_home_link_text()
        assert link_text == "Home", f"Текст ссылки должен быть 'Home', получено: '{link_text}'"
        
        # d. Проверяем href ссылки
        link_href = links_page.get_home_link_href()
        assert link_href == "https://demoqa.com", \
            f"Href ссылки должен быть 'https://demoqa.com', получено: '{link_href}'"
        
        # e. Проверяем открытие новой вкладки
        original_window = driver.current_window_handle
        window_count_before = len(driver.window_handles)
        
        links_page.click_home_link()
        
        # Ждем открытия новой вкладки
        import time
        time.sleep(2)
        
        window_count_after = len(driver.window_handles)
        assert window_count_after == window_count_before + 1, \
            f"Должна открыться новая вкладка. Было: {window_count_before}, стало: {window_count_after}"
        
        # Переключаемся на новую вкладку и проверяем URL
        new_window = [window for window in driver.window_handles if window != original_window][0]
        driver.switch_to.window(new_window)
        
        assert driver.current_url == "https://demoqa.com/", \
            f"URL новой вкладки должен быть 'https://demoqa.com/', получено: '{driver.current_url}'"
        
        # Возвращаемся к исходной вкладке и закрываем новую
        driver.close()
        driver.switch_to.window(original_window)
```

## 7. Page Object для ссылок

```python
# demoqa_home/pages/links_page.py
from pages.base_page import BasePage


class LinksPage(BasePage):
    """Класс для работы со страницей Links."""
    
    def __init__(self, driver):
        super().__init__(driver)
        self.url = "https://demoqa.com/links"
        
        # Локаторы элементов
        self.home_link = "#simpleLink"
    
    def visit(self):
        """Переход на страницу Links."""
        self.driver.get(self.url)
    
    def is_home_link_visible(self):
        """Проверяет видимость ссылки Home."""
        return self.is_element_visible(self.home_link)
    
    def get_home_link_text(self):
        """Получает текст ссылки Home."""
        return self.find_element(self.home_link).text
    
    def get_home_link_href(self):
        """Получает href ссылки Home."""
        return self.find_element(self.home_link).get_attribute("href")
    
    def click_home_link(self):
        """Клик по ссылке Home."""
        self.find_element(self.home_link).click()
```

## 8. Запуск тестов

```bash
# Запускаем все новые тесты
pytest tests/tests_hw/test_check_modal.py -v
pytest tests/tests_hw/test_check_alert.py -v
pytest tests/tests_hw/test_sort.py -v
pytest tests/tests_hw/test_window_tab.py -v

# Или все вместе
pytest tests/tests_hw/test_check_modal.py tests/tests_hw/test_check_alert.py tests/tests_hw/test_sort.py tests/tests_hw/test_window_tab.py -v
```

## 📁 Итоговая структура проекта:

```
demoqa_home/
├── pages/
│   ├── __init__.py
│   ├── base_page.py
│   ├── swag_labs.py
│   ├── demoqa_page.py
│   ├── accordion.py
│   ├── modal_dialogs.py
│   ├── text_box_page.py
│   ├── practice_form_page.py
│   ├── webtables_page.py
│   ├── alerts_page.py        # ← НОВЫЙ ФАЙЛ
│   └── links_page.py         # ← НОВЫЙ ФАЙЛ
├── tests/
│   ├── __init__.py
│   ├── test_check_swag.py
│   └── tests_hw/
│       ├── __init__.py
│       ├── test_check_text.py
│       ├── test_visible_hw.py
│       ├── test_page_dialogs.py
│       ├── test_text_box.py
│       ├── test_login_form_validate.py
│       ├── test_login_form.py
│       ├── test_webtables.py
│       ├── test_check_modal.py     # ← НОВЫЙ ФАЙЛ
│       ├── test_check_alert.py     # ← НОВЫЙ ФАЙЛ
│       ├── test_sort.py            # ← НОВЫЙ ФАЙЛ
│       └── test_window_tab.py      # ← НОВЫЙ ФАЙЛ
├── components/
│   ├── __init__.py
│   └── base_component.py
├── conftest.py
├── .gitignore
├── readme.md
└── requirements.txt
```

## 🔧 Особенности реализации:

1. **Проверка доступности страницы**: Использование requests для проверки `HTTP` статуса
2. **Работа с алертами**: Использование `Alert(driver)` для взаимодействия с `JavaScript` алертами
3. **Проверка сортировки**: Проверка `CSS` классов для определения состояния сортировки
4. **Управление вкладками**: Работа с множественными вкладками браузера
5. **Ожидания**: `time.sleep()` для таймерных операций (можно заменить на `WebDriverWait`)
