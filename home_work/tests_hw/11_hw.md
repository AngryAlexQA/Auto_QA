# Домашнее задание №11 - `Александра Бужор`

## 1. Page Object для WebTables

```python
# demoqa_home/pages/webtables_page.py
from pages.base_page import BasePage
from selenium.webdriver.common.by import By
from selenium.webdriver.support.ui import WebDriverWait
from selenium.webdriver.support import expected_conditions as EC


class WebTablesPage(BasePage):
    """Класс для работы со страницей Web Tables."""
    
    def __init__(self, driver):
        super().__init__(driver)
        self.url = "https://demoqa.com/webtables"
        
        # Локаторы элементов
        self.add_button = "#addNewRecordButton"
        self.submit_button = "#submit"
        self.registration_form = "#userForm"
        
        # Поля формы
        self.first_name_input = "#firstName"
        self.last_name_input = "#lastName"
        self.email_input = "#userEmail"
        self.age_input = "#age"
        self.salary_input = "#salary"
        self.department_input = "#department"
        
        # Элементы таблицы
        self.table_rows = ".rt-tr-group"
        self.edit_buttons = "span[title='Edit']"
        self.delete_buttons = "span[title='Delete']"
        
        # Пагинация
        self.page_info = "-pageInfo"
        self.next_button = "button.-next"
        self.previous_button = "button.-previous"
        self.rows_per_page_dropdown = "select[aria-label='rows per page']"
    
    def visit(self):
        """Переход на страницу Web Tables."""
        self.driver.get(self.url)
    
    def click_add_button(self):
        """Клик по кнопке Add."""
        element = self.find_element(self.add_button)
        element.click()
    
    def is_form_visible(self):
        """Проверяет видимость формы регистрации."""
        try:
            element = self.find_element(self.registration_form)
            return element.is_displayed()
        except:
            return False
    
    def fill_form(self, first_name, last_name, email, age, salary, department):
        """Заполняет форму данными."""
        self.find_element(self.first_name_input).send_keys(first_name)
        self.find_element(self.last_name_input).send_keys(last_name)
        self.find_element(self.email_input).send_keys(email)
        self.find_element(self.age_input).send_keys(age)
        self.find_element(self.salary_input).send_keys(salary)
        self.find_element(self.department_input).send_keys(department)
    
    def submit_form(self):
        """Отправляет форму."""
        self.find_element(self.submit_button).click()
    
    def get_table_rows_count(self):
        """Возвращает количество строк в таблице (исключая заголовок)."""
        rows = self.driver.find_elements(By.CSS_SELECTOR, self.table_rows)
        # Исключаем пустые строки и заголовок
        return len([row for row in rows if row.text.strip() and "First Name" not in row.text])
    
    def get_row_data(self, row_index):
        """Получает данные из строки таблицы."""
        rows = self.driver.find_elements(By.CSS_SELECTOR, self.table_rows)
        if row_index < len(rows):
            return rows[row_index].text
        return ""
    
    def click_edit_button(self, row_index):
        """Клик по кнопке редактирования в указанной строке."""
        edit_buttons = self.driver.find_elements(By.CSS_SELECTOR, self.edit_buttons)
        if row_index < len(edit_buttons):
            edit_buttons[row_index].click()
    
    def click_delete_button(self, row_index):
        """Клик по кнопке удаления в указанной строке."""
        delete_buttons = self.driver.find_elements(By.CSS_SELECTOR, self.delete_buttons)
        if row_index < len(delete_buttons):
            delete_buttons[row_index].click()
    
    def clear_first_name(self):
        """Очищает поле First Name."""
        element = self.find_element(self.first_name_input)
        element.clear()
    
    def set_rows_per_page(self, count):
        """Устанавливает количество строк на странице."""
        dropdown = self.find_element(self.rows_per_page_dropdown)
        dropdown.click()
        option = self.driver.find_element(By.CSS_SELECTOR, f"option[value='{count}']")
        option.click()
    
    def get_page_info(self):
        """Получает информацию о странице."""
        element = self.find_element(self.page_info)
        return element.text
    
    def is_next_button_enabled(self):
        """Проверяет, доступна ли кнопка Next."""
        element = self.find_element(self.next_button)
        return "disabled" not in element.get_attribute("class")
    
    def is_previous_button_enabled(self):
        """Проверяет, доступна ли кнопка Previous."""
        element = self.find_element(self.previous_button)
        return "disabled" not in element.get_attribute("class")
    
    def click_next_button(self):
        """Клик по кнопке Next."""
        if self.is_next_button_enabled():
            element = self.find_element(self.next_button)
            element.click()
    
    def click_previous_button(self):
        """Клик по кнопке Previous."""
        if self.is_previous_button_enabled():
            element = self.find_element(self.previous_button)
            element.click()
    
    def wait_for_form_to_close(self):
        """Ожидает закрытия формы."""
        WebDriverWait(self.driver, 5).until(
            EC.invisibility_of_element_located((By.CSS_SELECTOR, self.registration_form))
        )
```

## 2. Основной тест для WebTables

```python
# demoqa_home/tests/tests_hw/test_webtables.py
import pytest
import time
from pages.webtables_page import WebTablesPage


class TestWebTables:
    """Тесты для страницы Web Tables."""
    
    def test_web_tables_crud_operations(self, driver):
        """
        Тест CRUD операций в Web Tables.
        
        Steps:
        a. на странице имеется кнопка Add
        b. по клику на кнопку Add открывается диалоговое окно
        c. в диалоге нельзя сохранить пустую форму
        d. если заполнить все поля и нажать на кнопку Submit
           i. диалог закрывается
           ii. в таблицу добавляется новая запись с введенными данными
        e. если кликнуть на карандаш на строке записи
           i. открывается диалог с введенными данными
        f. если изменить имя и сохранить то в таблице обновляются данные
        g. если нажать на корзину в строке записи - запись удаляется
        """
        web_tables_page = WebTablesPage(driver)
        web_tables_page.visit()
        
        # a. Проверяем наличие кнопки Add
        assert web_tables_page.is_element_visible(web_tables_page.add_button) == True
        
        # b. Кликаем на кнопку Add и проверяем открытие диалога
        initial_rows_count = web_tables_page.get_table_rows_count()
        web_tables_page.click_add_button()
        assert web_tables_page.is_form_visible() == True
        
        # c. Пытаемся сохранить пустую форму
        web_tables_page.submit_form()
        assert web_tables_page.is_form_visible() == True, "Форма должна оставаться открытой при пустой отправке"
        
        # d. Заполняем все поля и сохраняем
        test_data = {
            "first_name": "Иван",
            "last_name": "Иванов",
            "email": "ivan@example.com",
            "age": "30",
            "salary": "50000",
            "department": "IT"
        }
        
        web_tables_page.fill_form(**test_data)
        web_tables_page.submit_form()
        
        # i. Проверяем закрытие диалога
        web_tables_page.wait_for_form_to_close()
        assert web_tables_page.is_form_visible() == False, "Форма должна закрыться после успешного сохранения"
        
        # ii. Проверяем добавление записи в таблицу
        new_rows_count = web_tables_page.get_table_rows_count()
        assert new_rows_count == initial_rows_count + 1, "Количество строк должно увеличиться на 1"
        
        # Проверяем данные в последней строке
        last_row_data = web_tables_page.get_row_data(new_rows_count - 1)
        for value in test_data.values():
            assert str(value) in last_row_data, f"Данные {value} должны быть в строке: {last_row_data}"
        
        # e. Редактирование записи
        web_tables_page.click_edit_button(0)  # Редактируем первую запись
        assert web_tables_page.is_form_visible() == True, "Форма должна открыться для редактирования"
        
        # f. Изменяем имя и сохраняем
        new_name = "Петр"
        web_tables_page.clear_first_name()
        web_tables_page.find_element(web_tables_page.first_name_input).send_keys(new_name)
        web_tables_page.submit_form()
        web_tables_page.wait_for_form_to_close()
        
        # Проверяем обновление данных
        updated_row_data = web_tables_page.get_row_data(0)
        assert new_name in updated_row_data, f"Имя должно быть обновлено на {new_name}"
        
        # g. Удаление записи
        initial_count_before_delete = web_tables_page.get_table_rows_count()
        web_tables_page.click_delete_button(0)  # Удаляем первую запись
        
        # Ждем обновления таблицы
        time.sleep(1)
        final_count = web_tables_page.get_table_rows_count()
        assert final_count == initial_count_before_delete - 1, "Количество строк должно уменьшиться на 1 после удаления"
    
    def test_web_tables_pagination(self, driver):
        """
        Тест пагинации в Web Tables.
        
        Steps:
        a. предусловия
           i. открыта страница
           ii. кол-во строк в таблице установлено 5
        b. тест кейс
           i. кнопки Next и Previous заблокированы
           ii. если добавить в таблицу еще 3 записи то:
               1. появляется 2-я страница (of 2)
               2. кнопка Next становится доступной
           iii. если кликнуть по кнопке Next то открывается 2-я страница
           iv. если кликнуть по кнопке Previous то открывается 1-я страница
        """
        web_tables_page = WebTablesPage(driver)
        web_tables_page.visit()
        
        # a. Устанавливаем 5 строк на странице
        web_tables_page.set_rows_per_page(5)
        time.sleep(1)  # Ждем применения настроек
        
        # b.i. Проверяем, что кнопки заблокированы изначально
        assert web_tables_page.is_next_button_enabled() == False, "Кнопка Next должна быть заблокирована"
        assert web_tables_page.is_previous_button_enabled() == False, "Кнопка Previous должна быть заблокирована"
        
        # b.ii. Добавляем 3 записи
        for i in range(3):
            web_tables_page.click_add_button()
            test_data = {
                "first_name": f"User{i}",
                "last_name": f"Test{i}",
                "email": f"user{i}@test.com",
                "age": str(25 + i),
                "salary": str(30000 + i * 1000),
                "department": f"Dept{i}"
            }
            web_tables_page.fill_form(**test_data)
            web_tables_page.submit_form()
            web_tables_page.wait_for_form_to_close()
            time.sleep(0.5)
        
        # 1. Проверяем информацию о странице
        page_info = web_tables_page.get_page_info()
        assert "of 2" in page_info, f"Должно быть 2 страницы, получено: {page_info}"
        
        # 2. Проверяем доступность кнопки Next
        assert web_tables_page.is_next_button_enabled() == True, "Кнопка Next должна стать доступной"
        
        # b.iii. Переходим на следующую страницу
        web_tables_page.click_next_button()
        time.sleep(1)
        
        # Проверяем, что мы на второй странице
        current_page_info = web_tables_page.get_page_info()
        assert "2" in current_page_info, f"Должны быть на второй странице, получено: {current_page_info}"
        
        # b.iv. Возвращаемся на предыдущую страницу
        web_tables_page.click_previous_button()
        time.sleep(1)
        
        # Проверяем, что вернулись на первую страницу
        final_page_info = web_tables_page.get_page_info()
        assert "1" in final_page_info, f"Должны вернуться на первую страницу, получено: {final_page_info}"
```

## 3. Запуск тестов

```bash
# Запускаем тесты для WebTables
pytest tests/tests_hw/test_webtables.py -v

# С подробным выводом
pytest tests/tests_hw/test_webtables.py -v --tb=short
```

## 📁 Итоговая структура проекта:

```
demoqa_home/
├── pages/
│   ├── __init__.py
│   ├── base_page.py
│   ├── swag_labs.py
│   ├── demoqa_page.py
│   ├── accordion.py
│   ├── modal_dialogs.py
│   ├── text_box_page.py
│   ├── practice_form_page.py
│   └── webtables_page.py      # ← НОВЫЙ ФАЙЛ
├── tests/
│   ├── __init__.py
│   ├── test_check_swag.py
│   └── tests_hw/
│       ├── __init__.py
│       ├── test_check_text.py
│       ├── test_visible_hw.py
│       ├── test_page_dialogs.py
│       ├── test_text_box.py
│       ├── test_login_form_validate.py
│       ├── test_login_form.py
│       └── test_webtables.py     # ← НОВЫЙ ФАЙЛ
├── components/
│   ├── __init__.py
│   └── base_component.py
├── conftest.py
├── .gitignore
├── readme.md
└── requirements.txt
```

## 🔧 Особенности реализации:

1. **CRUD операции**: Полный цикл `Create-Read-Update-Delete`
2. **Валидация формы**: Проверка невозможности сохранения пустой формы
3. **Пагинация**: Работа с многостраничной таблицей
4. **Динамические ожидания**: Использование `WebDriverWait` для стабильности тестов
5. **Универсальные методы**: Методы для работы с любым количеством записей
6. **Проверка состояний**: Проверка атрибутов `disabled/enabled` у кнопок.
